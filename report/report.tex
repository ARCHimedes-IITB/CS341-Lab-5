%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% DISCLAIMER: The original template for this
%%% file can be found at:
%%%
%%% https://www.overleaf.com/latex/templates/report-template-stima-laborations-overleaf-v1-dot-0/jtctxkqjnjdz
%%%
%%% Template for lab reports for CS341 @ IITB
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Sets the document class for the document
% Openany is added to remove the book style of starting every new chapter on an odd page (not needed for reports)
\documentclass[11pt, swedish, openany]{book}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Loading packages that alter the style
\usepackage[]{graphicx}
\usepackage[]{color}
\usepackage{alltt}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{multirow}
\usepackage{tablefootnote}
\usepackage{wrapfig}
\usepackage{amsmath}
\usepackage{placeins}
\usepackage{float}
\usepackage{subcaption}
\usepackage{makecell}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\setlength{\parskip}{\smallskipamount}
\setlength{\parindent}{0pt}

% Set page margins
\usepackage[top=100pt, bottom=100pt, left=60pt, right=60pt]{geometry}

% Package used for placeholder text
\usepackage{lipsum}

% Prevents LaTeX from filling out a page to the bottom
\raggedbottom

% Adding both languages, Swedish and English, so they can be used intermittently in for example abstracts.
\usepackage[swedish, english]{babel}

% All page numbers positioned at the bottom of the page
\usepackage{fancyhdr}
\fancyhf{} % clear all header and footers
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0pt} % remove the header rule
\pagestyle{fancy}

% Changes the style of chapter headings
\usepackage{titlesec}
\titleformat{\chapter}{\normalfont\LARGE\bfseries}{\thechapter.}{1em}{}
% Change distance between chapter header and text
\titlespacing{\chapter}{0pt}{50pt}{2\baselineskip}

% Adds table captions above the table per default
\usepackage{float}
\floatstyle{plaintop}
\restylefloat{table}

% Adds space between caption and table
\usepackage[tableposition=top]{caption}

% Adds hyperlinks to references and ToC
\usepackage{hyperref}
\hypersetup{hidelinks, linkcolor = blue} % Changes the link color to black and hides the hideous red border that usually is created

% If multiple images are to be added, a folder (path) with all the images can be added here
\graphicspath{{images/}}

% Separates the first part of the report/thesis in Roman numerals
\frontmatter


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Starts the document
\begin{document}

%%% Selects the language to be used for the first couple of pages
\selectlanguage{english}

%%%%% Adds the title page
\begin{titlepage}
  \clearpage\thispagestyle{empty}
  \centering
  \vspace{2cm}

  % Titles
  {\large CS341: Computer Architecture Lab\par}
  \vspace{4cm}
  {\Huge \textbf{Lab 5: Hacking ChampSim}} \\
  \vspace{0.2cm}
  {\huge \textbf{Report} \par}
  \vspace{4cm}
  % ========================================================
  % If this is a team-based project, add in your team-name,
  % team members along with roll numbers.
  %
  % If this is an individual project, remove the line
  % corresponding to team name and the remaining members
  % ========================================================
  {\normalsize {\large \textbf{Team ARCHimedes}}\\
    Vibhav Aggarwal (\texttt{190050128}) \\
    Adithya Bhaskar (\texttt{190050005}) \\
    Devansh Jain (\texttt{190100044}) \\
    Harshit Varma (\texttt{190100055}) \\
    Harshit Gupta (\texttt{190050048})
    %
    % Add more team members if there are any
    %
    \par}
  \vspace{2cm}
  \vfill

  \includegraphics[scale=0.30]{iitb_logo/iitb_logo.eps}

  \vspace{0.5cm}

  % Information about the University
  {\normalsize
    Department of Computer Science and Engineering \\
    Indian Institute of Technology Bombay  \par}

  % Set the date
  {\normalsize 2021-2022 \par}
  \vspace{2cm}

  \pagebreak

\end{titlepage}

% Adds a table of contents
\tableofcontents{}

\clearpage

% Uncomment the following three rows for a table of figures and/or tables as they are not needed for lab reports
% \listoffigures
% \clearpage
% \listoftables

\mainmatter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{\centerline{Abstract}}
Summarize the objective of the lab, what experiments you have conducted, what were the results that you have obtained in a clear and concise manner. Numbers matter, not just words only, for ex. \emph{very high}, \emph{slow} etc.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Understanding the problem statement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Understanding the problem statement}

\subsection{Understanding the code}
\begin{itemize}
    \item The \texttt{handle\_read} function is responsible for reading a query from the read queue and processing it.\\
    A read hit means that the line requested is present in the cache. So, the data is read from the cache itself. Following are the things that are done on a hit:
    \begin{itemize}
        \item Get a read request from the read queue \texttt{RQ}. If no read request, return.
        \item Get the set and the way corresponding to the request address. For a hit, there must be a way with same address as the requested one. This is done using the \texttt{get\_set} and \texttt{check\_hit} functions.
        \item Read the data and update it in the packet that we got from the read queue.
        \item If it is a load request, update the prefetcher using the prefetcher\_operate functions
        \item Update the replacement policy using the update\_replacement\_policy functions. aThis corresponds to bringing the accessed block to MRU position in the LRU scheme.
        \item Mark the entry in the MSHR of higher level as completed and add the data to it. This is done using the \texttt{return\_data} function for the correct upper level cache. Notice that for L1D, L1I, ITLB and DTLB do not have a higher level cache. Istead, they put the data in the PROCESSING queue.
        \item Update the statistics like number of hits and number of accesses.
    \end{itemize}
    \item A read miss means that the line requested is not present in the cache. In such a case, we do the following:(skipping over getting the query and detecting a miss as it is same as hit)
    \begin{itemize}
        \item First we need to check if there is a read request for the same address already in MSHR or not. If there is we can merge the requests. This is done using the \texttt{check\_mshr} function.
        \begin{itemize}
            \item If the address is not in MSHR, we need to add a new entry in MSHR and read queue of the lower level. Adding to MSHR is done using \texttt{add\_mshr} function. Adding to the lower level's read queue is done using \texttt{lower\_level->add\_rq} function. (This function also checks if the request can be served from the write queue or not and adds the request to read queue only if it can't be done)\\
            During the above operations, we need to ensure that we don't exceed the size of MSHR's and the queues. If this is the case, we must stall.
            \item If the address is in MSHR, we need to merge the requests.\\
            There is a member set named  \texttt{index\_depend\_on\_me} (different sets for load, store and instruction) in teh \texttt{PACKET} class. This set stores the index of all the requests depending on it. Merging indices amounts to joining the correct sets from request to MSHR entry and insert the index of request to the MSHR entry.
        \end{itemize}
        \item Update statistics like number of misses, number of MSHR entries merged etc.
    \end{itemize}
    \item The \texttt{handle\_fill} function is responsible for processing the completed requests in MSHR and put the data in correct position in the cache. Any function serving a read request uses \texttt{return\_data} which only adds the data to the MSHR entry for that address. But we need the data in cache and not in MSHR. The work of getting the data from MSHR and writing to cache is done by \texttt{handle\_fill}. That is why it needs to read (completed) request from MSHR.
    \item The lower\_level, upper\_level data members are declared in teh MEMORY class. Since CACHE class inherits from MEMORY, it also has these data members. They are assigned in \texttt{main.cc} in the \texttt{main} function for all the caches.\\
    These are arrays which store pointer to the next lower or next higher cache in the memory hierarchy (if they do not exist, then set to NULL). Since we have different instruction and data cache at L1, we need 2 different upper\_level cache array, one for data and one for instruction. So, for example for L2 cache, the values are:\\
    ooo\_cpu[i].upper\_level\_icache = ooo\_cpu[i].L1I\\
    ooo\_cpu[i].upper\_level\_dcache = ooo\_cpu[i].L1D\\
    ooo\_cpu[i].lower\_level = uncore.LLC\\
    Notice that L1D, L1I, L2 and the TLBs are CPU specific while the LLC and DRAM are shared. 
    \item The \texttt{return\_data} function is responsible for adding the data in an MSHR entry and marking it as completed. It takes a PACKET object as argument which stores the address and data. The basic workflow is: 
    \begin{itemize}
        \item Find the MSHR entry with the same address as the one mentioned in the given packet. This is done using \texttt{check\_mshr} function. If it does not exist, return error
        \item Mark the MSHR entry as completed(setting returned to COMPLETED) and add the data and metadata to the MSHR entry.
        \item Update the metrics like number of requests returned and latency
        \item Update \texttt{next\_fill\_index} using \texttt{update\_fill\_cycle} function. This index is the index from which \texttt{read\_fill} reads the request to be written in the cache.
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Implement LLC Bypassing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implement LLC Bypassing}
The relevant output files are in their respective directories, as required by the problem statement. We proceed to describe our implementation of MadCache. We begin with the description of the \textit{predictor} structure. Refer to the illustration below.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{images/predictor.png}
\end{figure}
The predictor consists of a global 10-bit counter (which determines the global default policy, initialized to 0111111111 or 511) and a set of entries each with their own counters which determines PC-specific policies. In particular, if the MSB of the global counter is 0, the default policy is LRU; else it is to use BBIP. Here, BBIP uses LRU 1/32-th of the time, and bypasses otherwise. Each entry contains:
\begin{itemize}
    \item \textbf{Default policy and PC:} This consists of the PC used when fetching the cacheline which led to the creation of this entry, and the default policy at the time. 
    \item \textbf{Counter:} A 6-bit counter governing the PC-specific policy, of 6 bits.
    \item \textbf{Number of entries:} This field tells us how many cachelines currently use this entry (0 if none).
\end{itemize}
Next we describe how we use this predictor to decide what to do with newly fetched cachelines from DRAM to the LLC. Refer to the flowchart below.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{images/newcacheline.png}
\end{figure}
If the \texttt{(Policy,PC)} pair exists in the predictor, we use the custom policy to decide what to do. This occurs even for lines not in tracker sets (we map those cachelines whose index bits have 0101 as the 4 LSBs as tracker sets; i.e. 1/16 of all cachelines are tracker sets). However, for these non-tracker lines we do \textbf{not} create an entry in the predictor. However, if the cacheline \textit{is} part of a tracker set, we check to see if an entry exists in the predictor. If so, we use the corresponding custom policy and increment its \texttt{\#entries} field if it happens to be LRU (we shouldn't and don't do this for Bypass since there is no cacheline allocated in that case). Otherwise, we fall back to using the default policy, and try to allocate a free predictor entry for this cacheline. If this succeeds, we initialize it with a counter of 011111 (``just'' LRU) and a \texttt{\#entries} field of 1. Note that if the allocation fails, we treat this cacheline just as if it were a non-tracker line henceforth (until new data is brought into it again).\\
If the policy used is LRU, we initialize the cacheline by setting \texttt{reuse=0} and the \texttt{pc\_pred\_index} to point to the allocated predictor entry.\\
Further, whenever we see a miss that maps to a tracker set, we check if we have a PC-specific policy for this PC. If so, we correspondingly change the global counter to penalize that specific type of behaviour (since it caused us a miss). This implements set dueling (or "PC dueling", rather) between the LRU and Bypass sets.
We next look at the lifetime of a tracker cacheline in the LLC. Refer to the flowchart below.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/lifecycle.png}
\end{figure}
A tracker cacheline starts out with a \texttt{reuse} bit of 0, and a counter initialized to 31 (if it was the first one for that entry). Whenever this cacheline sees a hit, it means that we were right to use LRU; thus we decrement the corresponding predictor entry's counter to make the behaviour more "LRU-like" for this PC. We also set \texttt{reuse=1} for this cacheline on a hit. On the other hand, when the cacheline is being evicted, if we see a reuse bit of 0, this means that the cacheline was never used again; we should have bypassed the LLC. Thus we increment the corresponding counter. In either case, we decrement the \texttt{\#entries} field of the counter on eviction, and if it falls to 0, de-allocate the predictor entry (so that it can be used by future misses).\\
\textbf{Modified files.} We modified the following files to implement the above scheme:
\begin{itemize}
    \item The files \texttt{inc/block.h} and \texttt{src/block.cc} contain the implementation of the predictor class.
    \item The file \texttt{inc/cache.h} has the definitions of a few helper functions and the modifications of the \texttt{CACHE} class to include the predictor.
    \item The file \texttt{src/cache.cc} contains the bulk of the changes, and implements the core logic of the above scheme. In particular, the functions that handle reads, writebacks and fills see extensive changes. Some other functions also see minor modifications.
\end{itemize}
\textbf{Impact on IPC.} The baseline LRU scheme gave an IPC of 0.142776 on average. On the other hand, our scheme gave an IPC of 0.171424 on average.\\
This corresponds to an increase (improvement) in IPC by roughly \textbf{20.065\%}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Prefetching
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Prefetching}


\section{The Throttle Policy}
<briefly describe the policy we used and the way we calculated accuracy and coverage>

\section{Results on different thresholds}
\subsection{L1D Prefetcher}
Here, we used the baseline parameters for L2C prefetcher and varied the threshold and upper bound for L1D. In the following figures, \texttt{x-y} represents that the threshold was set to \texttt{x} and the upper bound was set to \texttt{y} for that partiular run.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{images/L1D_table.png}
\end{figure}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{images/L1D_plot.png}
\end{figure}
\subsection{L2C Prefetcher}
Simialar to previous section, we varied the threshold and upper bound for L2C while keeping the baseline parameters for L1D.
% \begin{figure}[H]
%   \centering
%   \includegraphics[width=0.8\linewidth]{images/L2C_table.png}
% \end{figure}
% \begin{figure}[H]
%   \centering
%   \includegraphics[width=0.8\linewidth]{images/L2C_plot.png}
% \end{figure}
\section{Source files edited or added}
Added: \texttt{prefetchers/ip\_stride.l1d\_pref, inc/ip\_stride.h}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Contributions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Contributions}
 {\renewcommand{\arraystretch}{1.2}  % For increased padding
  \begin{table}[h]
    \centering
    \begin{tabular}{|c|c|p{6cm}|}
      \hline
      \textbf{Member} & \textbf{Work Done} \\
      \hline
      \hline
      Vibhav Aggarwal &                    \\
      Adithya Bhaskar &                    \\
      Devansh Jain    &                    \\
      Harshit Varma   &                    \\
      Harshit Gupta   &                    \\
      \hline
    \end{tabular}
    \caption{Contributions of each team member}
  \end{table}}



\end{document}
